+++
title = "tokio waker instrumentation"
slug = "tokio-waker-instrumentation"
author = "hds"
date = "2024-06-30"
draft = true
+++

This is going to be a short post on understanding how we can follow task dependency edges using the tracing instrumentation available in the [Tokio](https://tokio.rs/) async runtime. Specifically related to determining which task (if any) woke some other task. It will cover some of the same ground as a post from last year [tracing tokio tasks](@/posts/tracing-tokio-tasks.md), but focus more on the waker events. If you haven't read that post already, it may be worth doing so before continuing.

In async Rust, when the future driving a task returns [`Poll::Pending`](https://doc.rust-lang.org/std/task/enum.Poll.html), it won't be polled again until it gets woken by a waker. If you'd like to understand more about how pending futures get woken, you can read [how I finally understood async/await in Rust (part 2: how does a pending future get woken?)](@/posts/understanding-async-await-2.md).

## wake-up code

Let's start with some Rust code which we're going to analyse via the tracing instrumentation in tokio.

```rust
#[tokio::main]
async fn main() {
    use tracing_subscriber::prelude::*;
    let layer = ari_subscriber::Layer::new();
    tracing_subscriber::registry().with(layer).init();

    let (tx, mut rx) = tokio::sync::mpsc::channel(1);

    let receiver_jh = spawn_named("receiver", async move {
        tracing::debug!("self-wake: wake from same task (async)");
        self_wake().await;

        while rx.recv().await.is_some() {
            tracing::debug!("received message");
        }

        tracing::debug!("received None");
    });

    tokio::time::sleep(Duration::from_millis(10)).await;
    let task_tx = tx.clone();
    spawn_named("sender-task", async move {
        tracing::debug!("wake from another task (async)");
        task_tx.send(()).await.unwrap();
    })
    .await
    .unwrap();

    let no_runtime_tx = tx.clone();
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(10));

        tracing::debug!("wake from another thread (non-async)");
        no_runtime_tx.try_send(()).unwrap();
    })
    .join()
    .unwrap();

    drop(tx);
    receiver_jh.await.unwrap();
}

```

We're using a slightly modified version of my [`ari-subscriber`](https://github.com/hds/ari-subscriber), which adds colour coding to the spans and events generated by tokio's traces, to view the output. I introduced this crate in [debugging tokio instrumentation](@/posts/debugging-tokio-instrumentation.md). I'm hoping to integrate some of these changes behind builder options.

One of the main changes is to show each parent span and events on their own lines. This is much more appropriate for viewing in narrow spaces - like the code box on this web-site. The other change is that only `spawn` spans - those representing tasks, and `waker` events are included, the rest are filtered out. Here's the full output:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495210Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495363Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495416Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495469Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495532Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495579Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=dummy, task.id=2}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495667Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496063Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496115Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>self-wake: wake from same task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496171Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496234Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496289Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496340Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496401Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508063Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508183Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508240Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508753Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508824Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508878Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508929Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508978Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509039Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509132Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received message</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509187Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509253Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519517Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another thread (non-async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519585Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519695Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519788Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received message</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519839Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received None</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519907Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519954Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.520001Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.520046Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
</code></pre>

Since that's a lot of code and a lot of tracing output, let's go step by step.

We've got three different waker cases here, and we're going to look at each of them in turn:

- task wakes itself (self wake)
- task gets woken by another task
- task gets woken from outside the runtime

In the code snippet, we've got some tracing-subscriber set up code and then we create a multi-producer single-consumer channel. We only have one slot in the channel, but that's not integral to this example.

## self wake

A self-wake is what it sounds like, when a task wakes itself. Since a task can't do anything when it is not being polled, this means that the task must wake itself **before** it returns `Poll::Pending`. As such, when it does return `Poll::Pending`, it will be immediately ready to be polled again.

Here's the code that does this:

```rust
    let receiver_jh = spawn_named("receiver", async move {
        tracing::debug!("self-wake: wake from same task (async)");
        self_wake().await;

        // More things happen here
    });
```

We spawn a task with the name `receiver` which emits a DEBUG tracing event and then awaits a function called `self_wake()`. The exact contents of this function aren't important, but you can check it out at the bottom of this post under [self wake implementation](#self-wake-implementation). Likewise, the implementation of the `spawn_now()` function isn't important, it is just a convenience wrapper around Tokio's [`task::Builder](https://docs.rs/tokio/1.38.0/tokio/task/struct.Builder.html) API, check the implementation below under [spawn named implementation](#spawn-named-implementation).

Now let's look at the traces that correspond to this section of code.

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.495667Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496063Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496115Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>self-wake: wake from same task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496171Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496234Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496289Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
</code></pre>

Here we have six traces, each on multiple lines. Here's what happens:

1. `new` - the receiver task is created, it has the name `"receiver"` and the Tokio task ID `3`. The `runtime.spawn` span representing the task has span ID `2251799813685250`, this is seen in brackets `[]` after the name.
2. `enter` - the new task gets polled for the first time.
3. `tokio_spawn_wake` - this line is the output from the `tracing::debug` invocation in our own code (it has no colours).
4. `tokio::task::waker` - this is where our task wakes itself from inside `self_wake()`. Notice that the `task.id` here refers to the `runtime.spawn` span **representing** the task, not to Tokio's task ID. We know that this is a self wake because the value of the `task.id` field matches the span ID of the event's parent span.
5. `exit` - the task exits (it has returned `Poll::Pending`), this corresponds to the `.await` point called on `self_wake()`.
6. `enter` - because the task has already been woken and there is nothing else waiting, it is polled again immediately.

The most important take away here is how we know this is a self wake. It's because the value of the `task.id` field on the waker event matches the span ID of that event's parent span.

Here's that trace again with the values marked in red:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496171Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#df5853'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=<b><span style='color:#df5853'>2251799813685250</span></b></span>
</code></pre>

## wake from another task

The rest of the _receiver_ task's implementation is reading from the channel:

```rust
    let receiver_jh = spawn_named("receiver", async move {
        // self-wake code

        while rx.recv().await.is_some() {
            tracing::debug!("received message");
        }

        tracing::debug!("received None");
    });
```

This will asynchronously wait for a new message on the channel in a loop. It will exit once `None` is received, which will happen when all the channel's senders are dropped. We've added some DEBUG tracing events so that we can see when this task receives messages from the channel.

There are 2 traces that we didn't reach in the previous section, here they are:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496340Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.496401Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
</code></pre>

The first trace is a `tokio::task::waker` operation, specifically the waker is being cloned. This is being done by the `mpsc` channel. Since the channel is empty, `rx.recv().await` will return `Poll::Pending`. The task will be woken up when something comes into the channel to be received. To do this, the channel needs to hold onto the waker corresponding to the _receiver_ task so that it can invoke it when it can proceed. That's what the clone operation is.

The final line is the task returning `Poll::Pending` and moving into an idle state.

Now, let's look at what is happening with the channel's senders.

```rust
    tokio::time::sleep(Duration::from_millis(10)).await;
    let task_tx = tx.clone();
    spawn_named("sender-task", async move {
        tracing::debug!("wake from another task (async)");
        task_tx.send(()).await.unwrap();
    })
    .await
    .unwrap();
```

Here we use a bit of a hack, we wait for 10 milliseconds, this is to make sure that the the following doesn't get executed until after the self wake has occurred. This is likely not necessary, but worth adding to ensure repeatability in a learning context.

In this code, we are spawning a new task (which will immediately be scheduled to run). Inside the task, we emit a DEBUG tracing event and then send a message consisting of the unit struct `()` through the channel.

Here are the traces that correspond to this part of the code:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508063Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508183Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508240Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508753Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508824Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508878Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508929Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508978Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
</code></pre>

This section contains 8 traces, let's walk through them all in turn:

1. `new` - the `sender-task` task is created. It as Tokio Task ID `4` and the `runtime.spawn` span representing that task has span ID `2251799813685251`.
2. `enter` - the task is polled for the first time.
3. `tokio_spawn_wake` - the DEBUG event that we emitted from our code with `tracing::debug`.
4. `tokio::task::waker` - here is our waker operation, `waker.wake`. The `task.id` in this event is `2251799813685250`. Remember, this is the span ID of the `runtime.spawn` span representing a task. It isn't the same as the parent span, so we know we're waking some **other** task, if you check back up you'll see that it is indeed the receiver task that's being woken.
5. `exit` - the task exits. It's not clear from this trace, but the task has returned `Poll::Ready` and won't be polled again.
6. `enter` - the task span is entered again (see 8.)
7. `exit` - the task span is exited again (see 8.)
8. `close` - the task has been dropped. The task has now been destroyed and won't be polled again. The `enter` and `exit` in traces 6. and 7. don't actually indicate that the task gets polled an additional time. Tokio enters the span one last time to drop the task, which results in these extra steps.

Note that in trace 4. the operation is `waker.wake`, whereas in the self wake case the operation was `waker.wake_by_ref`. This is because the channel owns a waker. The channel's waker was cloned when the receiver task called `rx.recv().await` and will now be consumed! In the case of self waking, we didn't need to clone the waker as we were within the same task and could access it by reference.

We can tell that there was capacity in the channel to send our message, because otherwise the sender task would have exited and then entered again before being able to wake the receiver task. And of course it would have had to clone the waker so that it could be woken when capacity in the channel was available. But there was capacity, so none of this happened.

Another difference with the self wake case (perhaps **the** difference) is that in the `tokio::task::waker` event, the value of the `task.id` field is different to the span ID of the event's parent span (which represents the task which the wake operation occurred within). This is how we know that the receiver task was woken by some other task. It would be interesting to analyse the causality graph along the lines of waker operations.

Here's the trace with the two values highlighted in red:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.508753Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#df5853'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=<b><span style='color:#df5853'>2251799813685250</span></b></span>
</code></pre>

## wake from outside the runtime

Finally, let's take a look at some code that's going to wake our receiver task from outside the runtime. We spawn a new thread and then immediately sleep:

```rust
    let no_runtime_tx = tx.clone();
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(10));

        // Things done in the thread
    })
    .join()
    .unwrap();
```


We wait for 10 milliseconds again. Like before, the sleep is a hack to make sure that the receiver task has absolutely, positively consumed the message that was in the channel and has already awaited on receiving a new message.

Let's check the instrumentation to see that this is indeed happening:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509039Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509132Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received message</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509187Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.509253Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
</code></pre>

And it is! We can see that our receiver task enters (gets polled) and consumes the message from the channel, which we can see from the DEBUG message we emitted. The receiver task then clones its own waker (because the waker event `task.id` and the parent `runtime.spawn` span ID match) which means that it's awaiting receiving from the channel. Finally, the task exits, so it must have returned `Poll::Pending` as expected.

Now on to waking from outside the runtime.

```rust
    let no_runtime_tx = tx.clone();
    std::thread::spawn(move || {
        // That hacky sleep code

        tracing::debug!("wake from another thread (non-async)");
        no_runtime_tx.try_send(()).unwrap();
    })
    .join()
    .unwrap();
```

From our new thread, we emit a DEBUG tracing event and then send a message through the channel. Because we're not in an async context, we need to use the non-async `try_send` method on the channel's sender. We ensured that capacity would be available by sleeping for a little bit earlier, so we just unwrap the result like some uncouth villain.

Let's check the instrumentation from this episode:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519517Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another thread (non-async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519585Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
</code></pre>

This only consists of 2 traces. Standard library threads aren't instrumented, so we don't see anything about spawn the thread or starting execution in it until we get to the DEBUG tracing event that we emitted from our code. Then we see the `tokio::task::waker` event. We can see that the `task.id` field corresponds to the span ID for the receiver task `2251799813685250`, but that this event doesn't have a `runtime.spawn` parent span. In fact, it doesn't have a parent span at all (we call this a root event).

This tells us that the task was woken from outside the async runtime, which can be useful information in and of itself.

## finishing up

That's the extent of the waker traces emitted from our program, but let's round things up by running through the last few lines of code and the traces that are produced. We're left with two lines of code:

```rust
    drop(tx);
    receiver_jh.await.unwrap();
```

Here we drop the channel sender that was held in the main task (it was never actually used, just cloned into the async task and the thread). This is the last sender, so this will cause the receiver task to exit the `while` loop it is in. Then, we await the receiver task's join handle to make sure that it has exited and then we're done.

Let's look at the last of the traces:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519695Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519788Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received message</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519839Z</span> <span style='color:#5c8dce'>DEBUG</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span> 
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>received None</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519907Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.519954Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.520001Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-20</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>15:10:05</span></b></span><span style='opacity:0.67'>.520046Z</span> <span style='color:#9d4edd'>TRACE</span> 
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
</code></pre>

We've got 7 traces here, so we'll go through them one by one:

1. `enter` - the receiver task gets polled (woken by the other thread).
2. `tokio_spawn_wake` - the receiver task receives a message from the channel
3. `tokio_spawn_wake` - the receiver task receives `None` from the channel, indicating that all the senders have been dropped and the channel is closed
4. `exit` - the receiver task exits.
5. `enter` - the receiver task's `runtime.spawn` span enters (that funny enter-exit at the end that isn't really a poll)
6. `exit` - the receiver task's `runtime.spawn` span exits (that funny enter-exit at the end that isn't really a poll)
7. `close` - the receiver task is dropped

We can see here that the last sender gets dropped before the receiver task has finished receiving the previous message and looped back around to call `recv().await` again. Since the channel has closed by this point, the receiver task gets the notification straight away (no returning `Poll::Pending`). There's no cloning of the waker or exiting.

This is the end of the main part of the post. Below you'll find the implementation of the functions `spawn_named()` and `self_wake()` that were used within the example code.

If you have suggestions or corrections, please [get in touch](@/about.md#contact).

## spawn named implementation

This implementation wraps the task builder API (which is [unstable](https://docs.rs/tokio/1.38.0/tokio/index.html#unstable-features)) to reduce the code in the main function.

```rust
use std::future::Future;

#[track_caller]
fn spawn_named<Fut>(name: &str, f: Fut) -> tokio::task::JoinHandle<<Fut as Future>::Output>
where
    Fut: Future + Send + 'static,
    Fut::Output: Send + 'static,
{
    tokio::task::Builder::new()
        .name(name)
        .spawn(f)
        .unwrap_or_else(|_| panic!("spawning task '{name}' failed"))
}
```

## self wake implementation

This is the implementation for `self_wake()`, it's based on the old implementation of [`yield_now()`](https://docs.rs/tokio/1.38.0/tokio/task/fn.yield_now.html) in tokio, before it was replaced with a more complex version that doesn't starve the I/O driver (done in [tokio-rs/tokio#5223](https://github.com/tokio-rs/tokio/pull/5223)).

The function returns a type erased future which will check whether it has already yielded. If it has, it will return `Poll::Ready`, otherwise it will record that it is about to yield, wake the waker it received in the context parameter to the poll function and then return `Poll::Pending`.

```rust
use std::{future::Future, task::Poll};

fn self_wake() -> impl Future<Output = ()> {
    struct SelfWake {
        yielded: bool,
    }

    impl Future for SelfWake {
        type Output = ();
        fn poll(
            mut self: std::pin::Pin<&mut Self>,
            cx: &mut std::task::Context<'_>,
        ) -> Poll<Self::Output> {
            if self.yielded {
                return Poll::Ready(());
            }

            self.yielded = true;
            cx.waker().wake_by_ref();

            Poll::Pending
        }
    }

    SelfWake { yielded: false }
}
```
