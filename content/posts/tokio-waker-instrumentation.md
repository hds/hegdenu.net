+++
title = "tokio waker instrumentation"
slug = "tokio-waker-instrumentation"
author = "hds"
date = "2024-06-30"
draft = true
+++

This is going to be a short post on understanding how we can follow task dependency edges using the tracing instrumentation available in the [Tokio](https://tokio.rs/) async runtime. Specifically related to determining which task (if any) woke some other task. It will cover some of the same ground as a post from last year [tracing tokio tasks](@/posts/tracing-tokio-tasks.md), but focus more on the waker events. If you haven't read that post already, it may be worth doing so before continuing.

In async Rust, when the future driving a task returns [`Poll::Pending`](https://doc.rust-lang.org/std/task/enum.Poll.html), it won't be polled again until it gets woken by a waker. If you'd like to understand more about how pending futures get woken, you can read [how I finally understood async/await in Rust (part 2: how does a pending future get woken?)](@/posts/understanding-async-await-2.md).

## wake-up code

Let's start with some Rust code which we're going to analyse via the tracing instrumentation in tokio.

```rust
#[tokio::main]
async fn main() {
    use tracing_subscriber::prelude::*;
    let layer = ari_subscriber::Layer::new();
    tracing_subscriber::registry().with(layer).init();

    let (tx, mut rx) = tokio::sync::mpsc::channel(1);

    let receiver_jh = spawn_named("receiver", async move {
        tracing::debug!("self-wake: wake from same task (async)");
        self_wake().await;

        while rx.recv().await.is_some() {
            // do nothing
        }
    });

    tokio::time::sleep(Duration::from_millis(10)).await;
    let task_tx = tx.clone();
    spawn_named("sender-task", async move {
        tracing::debug!("wake from another task (async)");
        task_tx.send(()).await.unwrap();
    })
    .await
    .unwrap();

    let no_runtime_tx = tx.clone();
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(10));

        tracing::debug!("wake from another thread (non-async)");
        no_runtime_tx.try_send(()).unwrap();
    })
    .join()
    .unwrap();

    drop(tx);
    receiver_jh.await.unwrap();
}
```

We're using a slightly modified version of my [`ari-subscriber`](https://github.com/hds/ari-subscriber), which adds colour coding to the spans and events generated by tokio's traces, to view the output. I introduced this crate in [debugging tokio instrumentation](@/posts/debugging-tokio-instrumentation.md). I'm hoping to integrate some of these changes behind builder options.

One of the main changes is to show each parent span and events on their own lines. This is much more appropriate for viewing in narrow spaces - like the code box on this web-site. The other change is that only `spawn` spans - those representing tasks, and `waker` events are included, the rest are filtered out. Here's the full output:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217102Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217478Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217527Z</span> <span style='color:#5c8dce'>DEBUG</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>self-wake: wake from same task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217578Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217667Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217774Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217821Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217877Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230208Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230298Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230346Z</span> <span style='color:#5c8dce'>DEBUG</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230766Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230824Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230870Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230914Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.230956Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685251</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=sender-task, task.id=4}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.231009Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.231090Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.231143Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241340Z</span> <span style='color:#5c8dce'>DEBUG</span>
   <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>wake from another thread (non-async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241403Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241505Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241608Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241654Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241698Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.241741Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>close</span></u></b>
</code></pre>

Since that's a lot of code and a lot of tracing output, let's go step by step.

We've got three different waker cases here, and we're going to look at each of them in turn:

- task wakes itself (self wake)
- task gets woken by another task
- task gets woken from outside the runtime

In the code snippet, we've got some tracing-subscriber set up code and then we create a multi-producer single-consumer channel. We only have one slot in the channel, but that's not integral to this example.

## self wake

A self-wake is what it sounds like, when a task wakes itself. Since a task can't do anything when it is not being polled, this means that the task must wake itself **before** it returns `Poll::Pending`. As such, when it does return `Poll::Pending`, it will be immediately ready to be polled again.

Here's the code that does this:

```rust
    let receiver_jh = spawn_named("receiver", async move {
        tracing::debug!("self-wake: wake from same task (async)");
        self_wake().await;

        // More things happen here
    });
```

We spawn a task with the name `receiver` which emits a DEBUG tracing event and then awaits a function called `self_wake()`. The exact contents of this function aren't important, but you can check it out at the bottom of this post under [self wake implementation](#self-wake-implementation). Likewise, the implementation of the `spawn_now()` function isn't important, it is just a convenience wrapper around Tokio's [`task::Builder](https://docs.rs/tokio/1.38.0/tokio/task/struct.Builder.html) API, check the implementation below under [spawn named implementation](#spawn-named-implementation).

Now let's look at the traces that correspond to this section of code.

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217102Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>new</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217478Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217527Z</span> <span style='color:#5c8dce'>DEBUG</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#aaa'>⤷</span> <b><span style='color:#aaa'>tokio_spawn_wake</span></b>: <span style='color:#aaa'>self-wake: wake from same task (async)</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217578Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217667Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217774Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>enter</span></u></b>
</code></pre>

Here we have six traces, each on multiple lines. Here's what happens:

1. `new` - the receiver task is created, it has the name `"receiver"` and the Tokio task ID `3`. The `runtime.spawn` span representing the task has span ID `2251799813685250`, this is seen in brackets `[]` after the name.
2. `enter` - the new task gets polled for the first time.
3. `tokio_spawn_wake` - this line is the output from the `tracing::debug` invocation in our own code (it has no colours).
4. `tokio::task::waker` - this is where our task wakes itself from inside `self_wake()`. Notice that the `task.id` here refers to the `runtime.spawn` span **representing** the task, not to Tokio's task ID. We know that this is a self wake because the value of the `task.id` field matches the span ID of the event's parent span.
5. `exit` - the task exits (it has returned `Poll::Pending`), this corresponds to the `.await` point called on `self_wake()`.
6. `enter` - because the task has already been woken and there is nothing else waiting, it is polled again immediately.

The most important take away here is how we know this is a self wake. It's because the value of the `task.id` field on the waker event matches the span ID of that event's parent span.

Here's that trace again with the values marked in red:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217578Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#df5853'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.wake_by_ref&quot;, task.id=<b><span style='color:#df5853'>2251799813685250</span></b></span>
</code></pre>

## wake from another task

The rest of the _receiver_ task's implementation is reading from the channel:

```rust
    let receiver_jh = spawn_named("receiver", async move {
        // self-wake code

        while rx.recv().await.is_some() {
            // do nothing
        }
    });
```

This will asynchronously wait for a new message on the channel in a loop. It will exit once `None` is received, which will happen when all the channel's senders are dropped.

There are 2 traces that we didn't reach in the previous section, here they are:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom"><span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217821Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>
     <span style='color:#9d4edd'>⤷</span> <b><span style='color:#c77dff'>tokio::task::waker</span></b>: <span style='color:#9d4edd'>op=&quot;waker.clone&quot;, task.id=2251799813685250</span>
<span style='opacity:0.67'><b><span style='color:#aaa'>2024-06-18</span></b></span><span style='opacity:0.67'>T<b><span style='color:#aaa'>10:45:11</span></b></span><span style='opacity:0.67'>.217877Z</span> <span style='color:#9d4edd'>TRACE</span>
   <span style='color:#489e6c'>⤷</span> <span style='color:#489e6c'>runtime.spawn[<b><span style='color:#5aba84'>2251799813685250</span></b></span><span style='color:#489e6c'>]{kind=task, task.name=receiver, task.id=3}</span>  <b><u><span style='color:#5aba84'>exit</span></u></b>
</code></pre>

The first trace is a `tokio::task::waker` operation, specifically the waker is being cloned. This is being done by the `mpsc` channel. Since the channel is empty, `rx.recv().await` will return `Poll::Pending`. The task will be woken up when something comes into the channel to be received. To do this, the channel needs to hold onto the waker corresponding to the _receiver_ task so that it can invoke it when it can proceed. That's what the clone operation is.

The final line is the task returning `Poll::Pending` and moving into an idle state.

Now, let's look at what is happening with the channel's senders.

```rust
tokio::time::sleep(Duration::from_millis(10)).await;
let task_tx = tx.clone();
spawn_named("sender-task", async move {
    tracing::debug!("wake from another task (async)");
    task_tx.send(()).await.unwrap();
})
.await
.unwrap();
```

Here we use a bit of a hack, we wait for 10 milliseconds, this is to make sure that the the following doesn't get executed until after the self wake has occurred. This is likely not necessary, but worth adding to ensure repeatability in a learning context.

Here are the traces that correspond to this part of the code:

<pre data-lang="custom" style="background-color:#2b303b;color:#c0c5ce;" class="language-custom "><code class="language-custom" data-lang="custom">
</code></pre>

Then we create a new task called `"sender-task"` and give it a clone of the channel's `Sender`.

## spawn named implementation

This implementation wraps the task builder API (which is [unstable](https://docs.rs/tokio/1.38.0/tokio/index.html#unstable-features)) to reduce the code in the main function.

```rust
use std::future::Future;

#[track_caller]
fn spawn_named<Fut>(name: &str, f: Fut) -> tokio::task::JoinHandle<<Fut as Future>::Output>
where
    Fut: Future + Send + 'static,
    Fut::Output: Send + 'static,
{
    tokio::task::Builder::new()
        .name(name)
        .spawn(f)
        .unwrap_or_else(|_| panic!("spawning task '{name}' failed"))
}
```

## self wake implementation

This is the implementation for `self_wake()`, it's based on the old implementation of [`yield_now()`](https://docs.rs/tokio/1.38.0/tokio/task/fn.yield_now.html) in tokio, before it was replaced with a more complex version that doesn't starve the I/O driver (done in [tokio-rs/tokio#5223](https://github.com/tokio-rs/tokio/pull/5223)).

The function returns a type erased future which will check whether it has already yielded. If it has, it will return `Poll::Ready`, otherwise it will record that it is about to yield, wake the waker it received in the context parameter to the poll function and then return `Poll::Pending`.

```rust
use std::{future::Future, task::Poll};

fn self_wake() -> impl Future<Output = ()> {
    struct SelfWake {
        yielded: bool,
    }

    impl Future for SelfWake {
        type Output = ();
        fn poll(
            mut self: std::pin::Pin<&mut Self>,
            cx: &mut std::task::Context<'_>,
        ) -> Poll<Self::Output> {
            if self.yielded {
                return Poll::Ready(());
            }

            self.yielded = true;
            cx.waker().wake_by_ref();

            Poll::Pending
        }
    }

    SelfWake { yielded: false }
}
```
